\documentclass[10pt,
%handout
aspectratio=169
]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{nicefrac}
\usepackage{braket}

%\usepackage[backend=biber,style=chem-acs]{biblatex}
%\bibliography{biblio}


\usetheme{metropolis}
\setbeamercolor{block title}{use=structure,fg=white,bg=structure.fg!75!black}
\setbeamercolor{block body}{parent=normal text,use=block title,bg=block title.bg!10!bg}


\usepackage{tikz}
\usetikzlibrary{positioning, decorations.markings, decorations.pathmorphing, calc}

\usepackage{siunitx}
\usepackage{mhchem}
\usepackage{minted}
\setminted{  
	frame=lines,  
	framesep=2mm,  
	baselinestretch=1.2,  
	fontsize=\footnotesize,  
	linenos,  
	breaklines,
	tabsize=2
}  

\author{Pierre Beaujean (\href{mailto:pierre.beaujean@unamur.be}{pierre.beaujean@unamur.be})}
\title{Advanced Python for advanced users}
\subtitle{... And a few concepts of computer science}
\institute{University of Namur}
\date{March 2025 (version of  \today)}

\allowdisplaybreaks

\begin{document}
\begin{frame}[plain]
	\maketitle
\end{frame}

\begin{frame}{Table of content}
	\tableofcontents
\end{frame}

\section{Back to basics}

\begin{frame}{Computer?}
	As far as you are concerned, a computer contains:\begin{itemize}
		\item A \textbf{CPU}, which execute (\textit{assembler}) code. Nowadays, there are also \textbf{GPUs} which can fulfill this role.
		\item Different kind of \textbf{memories} (cache, RAM, disk, etc), some of which can be addressed differently (\textit{e.g.}, through files).
		\item Some interfaces to the outside world, via peripherics (screen,  mouse, Ethernet, etc).
	\end{itemize}
	
	By itself, the CPU only moves bytes around in memory, and can perform operation on them. It understands the concept of \textbf{integers} and \textbf{floating point numbers} (IEEE-754 shenanigans), but that's about it. 
	
	Most functionalities of a computer (\textit{e.g.}, files) are in fact available thanks to the \textbf{operating system}, which offers, \textit{e.g.}, an unified interface to peripherics.
\end{frame}

\begin{frame}
	The \textbf{assembler} is a pretty simple (and CPU-dependent) language. For example, it does not understand the concept of strings (which explains why Fortran and C implements them differently). And, among other things, \textit{advanced} concepts like \textit{loops} are not directly available.
	
	 So... A meme will now ensue.
	
	\begin{center}
		\includegraphics[width=.6\linewidth]{im/meme-goto}
		
		(Note: it is in fact \textbf{conditional jumps})
	\end{center}
\end{frame}

\begin{frame}{Programming in Python}
	A programming language enables you to express complex logic (\textit{e.g.}, loops, conditionals) in a structured and readable manner. This code is then either translated into machine instructions by a \textbf{compiler} or executed directly by an \textbf{interpreter}. While interpreted languages tend to be slower, they offer advantages such as dynamic execution (\mintinline{python}|exec()|), reflexivity (\mintinline{python}|getattr()|), and the ability to modify itself at runtime.
	
	Python is an \textbf{interpreted} language, but it is also \textit{just-in-time compiled} into an intermediate bytecode representation (stored in \mintinline{text}|__pycache__|). Over time, this process optimizes execution by reducing redundant checks, making subsequent runs of the code faster.
\end{frame}



\begin{frame}[fragile]
	The way to write the code is referred to as a \textbf{programming paradigm}, a relatively high-level way to conceptualize and structure the implementation of a computer program.\footnote{\url{https://en.wikipedia.org/wiki/Programming_paradigm}} Among others, there are:\begin{itemize}
		\item \textbf{Imperative}, in which the code directly controls execution flow and state change. This includes the famous \textbf{procedural} (\mintinline{text}|x = a(); y = b(x);|) and \textbf{object-oriented} (\mintinline{text}|x = X(); x.b();|) approaches.
		\item \textbf{Declarative}, in which code declares properties of the desired result, but not how to compute it, it describes what computation should be performed. This include the (in)famous \textbf{functional} approach (\mintinline{text}|(b(a()))|), but also programs based on \textbf{logic and constraints} (\mintinline{text}|x: int; y: int; x+y < 3;|).
		\item But also: \textbf{concurrent}, \textbf{visual}, etc...
	\end{itemize}
	
	To a certain extent, all paradigm can be used in all languages. Python is generally approached as an POO language.
	\vspace{1em}
\end{frame}

\section{General concepts for programming}

\begin{frame}{Note on the ``who''}
	In this  part, I will distinguish three kinds of people:\begin{enumerate}
		\item The \textbf{developers}, who actually develop the code/library and eventually provide an API (\textit{application programming interface}).
		\item The \textbf{programmers}, who use the API provided by the code/library and develop on top of it.
		\item The \textbf{users}, who use the program/executable, but do not program.
	\end{enumerate}
\end{frame}

\begin{frame}{Abstractions}
	A well-designed program should be \textbf{modular}, with each module having clear and specific responsibilities. They can then work together . One of the best ways to achieve this is through \textbf{abstraction}, which means focusing on what matters while ignoring unnecessary details. There are several levels of abstraction:
	\begin{enumerate}
		\item \textbf{Abstraction by Parameterization}: Use parameters instead of hard-coded values to make code flexible and reusable.
		\item \textbf{Abstraction by Procedures}: Structure your code using functions that call one another, rather than relying on \textit{copy-paste-modify} patterns.
		\item \textbf{Abstraction by Specification}: Describe \textbf{what} the code should do, not \textbf{how} it does it. This allows you to change the implementation without affecting other parts of the program. (More on this later.)
		\item \textbf{Data Abstraction}: Instead of using raw data, encapsulate it in \textbf{abstract data types} (e.g., objects). Type hierarchies using \textbf{inheritance}, with child classes inheriting behaviors from parent classes. (More on this later.)
		\item And others: syntaxic sugar, etc.
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]
	Example(s):
	\begin{minted}{python}
# without any abstraction
print('perimeter of circle is', 2 * 3.141592 * 3.5)
print('area is', 3.141592 * 3.5 ** 2)
# abstraction by parameterization
PI = 3.141592
r = 3.5
print('perimeter of circle is', 2 * PI * r)
print('area is', PI * r ** 2)
# abstraction by procedure
from math import pi as PI

def info_circle(r: float) -> None:
	print('perimeter of circle is', 2 * PI * r)
	print('area is', PI * r ** 2)

info_circle(3.5)
info_circle(7.2)
\end{minted}
\end{frame}


\begin{frame}[fragile]
	An example of data abstraction (\texttt{fp32}):
	\begin{center}
		\begin{tikzpicture}
			\draw (0, 0) rectangle +(1, 1)  node[midway] {$\mathcal{S}$};
			\draw (1.5, 0) rectangle +(2, 1)  node[midway] {$\mathcal{E}$};;
			\draw (4, 0) rectangle +(5, 1)  node[midway] {$\mathcal{M}$};
			\draw[latex-latex] (0,1.25) -- +(1,0) node[midway,above]{1 bit};
			\draw[latex-latex] (1.5,1.25) -- +(2,0) node[midway,above]{8 bit};
			\draw[latex-latex] (4,1.25) -- +(5,0) node[midway,above]{23 bit};
			\draw[latex-latex] (0,-.25) -- +(9,0) node[midway,below]{32 bit};
		\end{tikzpicture}
		\begin{equation*}
			x = (-1)^\mathcal{S} \times 2^{\mathcal{E}-2^7} \times \left(1+\frac{\mathcal M}{2^{23}}\right).
		\end{equation*}
	\end{center}
	And yet...
	\begin{minted}{python}
# let's play with floats:
x = 2.5e7  # S=0, E=151, M=4111392
y = x - 3.25e-2
	\end{minted}
	This is a powerful abstraction!
\end{frame}

\begin{frame}{Design by contract (i.e., abstraction by specification)}
	\vspace*{1em}
	\begin{columns}
	\column{.5\linewidth}
	\parskip=1em
	The ``design by contract" approach prescribes that developers should define formal(?), precise(?) and verifiable(?) interface \textbf{specifications} for software components (functions, classes, modules, programs, etc). 
	
	The ``contract'' is the following: $\{P\land I\} \,\underline{S}\,\{Q\land I\}$ ($\land$ side effects). Generally, $\lnot (P \land I)\implies \text{errors}$, but it is not necessarily true in all cases (and it does not have to be). 
	
	\textbf{Notice that this does not say what is $\underline{S}$.} This is thus mostly useful for the programmer (and the user).
	
	\column{.5\linewidth}
	\begin{center}
		\begin{tikzpicture}
			\draw[blue,fill=blue!15] (0, 0) rectangle +(4, 3);
			\draw[blue]  (0, -.5) node[anchor=south west,rotate=90]{Software component ($\underline{S}$)};
			\draw[-latex,very thick] (2, 3.5) node[above]{Preconditions ($P$)}-- +(0, -1);
			\draw[-latex,very thick] (2, 0.5) node[above]{Postconditions  ($Q$)}-- +(0, -1);
			\draw[-latex,very thick] (3.5, 2.25) -- +(1, 0) node[right]{Errors};
			\draw[-latex,very thick] (3.5, 1.75) -- +(1, 0) node[right]{Side effects};
			\draw (2, 2) node{Invariants ($I$)};
		\end{tikzpicture}
	\end{center}
	\vspace*{1em}
	+ Eventual performances guarantees.
	\end{columns}
\end{frame}

\begin{frame}
	\vspace*{1em}
	\begin{columns}
		\column{.5\linewidth}
		\begin{itemize}
			\item The \textbf{preconditions} are predicates that must be true before the execution of the component (it generally boils down to the type of the inputs and their respective domains). It must be guaranteed by \textbf{the caller}. If a precondition is violated, the effect becomes undefined.
			\item The \textbf{postconditions} are predicates that must be true after execution (if the preconditions are true), which is guaranteed by the \textbf{callee}.
			\item The \textbf{invariants} are predicates that must be true before and after execution. This is guaranteed by the caller \textbf{and} the callee (but mostly the later).
		\end{itemize}
		
		\column{.4\linewidth}
		\begin{center}
			\includegraphics[width=\linewidth]{im/meme-prepost}
		\end{center}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	Example: $P \equiv x\in\mathbb{R}$ (not necessarily true in python!), $Q\equiv \mathcal{R} = |x|$, $I \equiv \text{yes}$, $\underline{S} \equiv$\begin{minted}{python}
def _abs(x: float) -> float:
	return -x if x < 0 else x  # note: that's called syntaxic sugar
	\end{minted}
	Here, $sp(\underline{S}, P \land I) \implies Q \land I$, so this program is valid. Indeed, \begin{align*}
		Q' &= sp(\text{\mintinline{python}|-x if x < 0 else x|}, x\in\mathbb{R}) \\
		&= (\mathcal{R} = -x \land x < 0 \land x\in\mathbb{R}) \lor (\mathcal{R} = x \land x \geq 0 \land x\in\mathbb{R})\\
		&= [(\mathcal{R} = -x \land x < 0) \lor (\mathcal{R} = x \land x \geq 0)]  \land x\in\mathbb{R}
	\end{align*}
	and $Q' \implies Q \land I$. Note that \mintinline{python}|_abs("test")| is indeed undefined.
	
	This is how you should ensure that your programs are valid, except nobody does that in practice (except in security contexts, like planes, trains, or in space). Note that one of the implicit assumption is that the interpreter works correctly (so you also need to ``prove" the interpreter if you want to be 100\% correct).
\end{frame}

\begin{frame}
	\begin{itemize}
		\item \textbf{Errors:} we will see below how to play with errors, but if one sticks to \textit{design by contract} alone, this is not required, since the preconditions \textbf{must always} be fulfilled. In practice, it is generally not the case (\textit{never trust user input}!), so one can perform \textbf{defensive programming} instead, which consists in checking the preconditions, and either failing (throwing exceptions) or running in degraded mode\footnote{Purely falling would be a bit annoying in a plane ;)} if they are not fulfilled.
		 \item This leads to \textbf{side-effects}, which is the fact that the code have an observable effect other than reading its input and giving an output. Other example of side-effects include: performing I/O, modifying a non-local variable (\textit{e.g.}, matplotlib's \mintinline{python}|pyplot| interface, which is a state machine), or mutate an argument (\textit{e.g.}, sorting a list in-place).\footnote{BLAS and LAPACK are customary of such practices.} \textbf{All} such side-effects should be \textbf{properly} documented.
	\end{itemize}
\end{frame}

\begin{frame}
	In practice, be nice to your programmers/users (... and to future you, for that matter) that your \textbf{specifications} contains the following:\begin{itemize}
		\item Document your inputs, it is better than nothing. This include their types (in some language, it is in the definitions) and their \textbf{domain} (\textit{e.g.}, for \mintinline{python}|sqrt(x)|, \mintinline{python}|x >= 0|).
		\item Document the \textbf{effect} of the code rather than what it does (which does not prevent you to have another document which details the algorithms).
		\item If possible, document all \textbf{side effects}, in particular if you mutate an argument.
	\end{itemize}
	
	Since you will probably never properly prove your pre/postconditions, you don't have to use a mathematical language to express everything.\footnote{personally, I write my pre/post-conditions using the programming language itself, for example \mintinline{python}|x >= 0 and 0 <= y < 3 and z in ['a', 'b', 'c']|.} Even if any spoken language is ambiguous, a nice textual description is better than nothing.
	
	The goal is therefore to provide a ``framework" for things you should document, rather than a set of rules.
\end{frame}

\begin{frame}{Documentation}
	\begin{itemize}
		\item The documentation is therefore the place where you indicate your pre/post-conditions, side effects, etc. Note that these concepts applies to any component you can think of (even a CLI program has inputs and outputs), although with different names. Again, ``framework'' rather than set of rules.
		\item Be nice to your programmers/users: details the installation procedure as much as possible (detail the dependencies if any), provide examples,\footnote{... But an example alone is not a good documentation, thought.} etc. We all have in mind good and bad documentation... Let's not be an example of the latter ;)
		\item There is no convention for the form of your documentation (it can be done with any tool you want), but it is generally better to diminish the amount of manual work, which means that documentation \textbf{auto-generation} is a good idea.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	The idea of auto-generation is to write a part of your documentation directly in the code as comments, then to use a tool that read such comments  and generate a nice document (generally a set of HTML pages) as output. 
	
	The tool of the trade here is generally Doxygen (see \url{https://www.doxygen.nl/}), which was first created for C++:
	\begin{minted}{cpp}
class Dog {
	public:
	/**
	* \brief Creates a new Dog.
	*
	* Creates a new Dog named `_name`.
	*
	* \param _name The dog's name.
	*/
	Dog(const char* _name);
};
	\end{minted}
	... But works for many languages (including Python and Fortran).
\end{frame}

\begin{frame}
	But in Python, nobody  agrees yet.\footnote{Sphinx seems to win for major projects, thought.} There are three concurrent documentation formats (ReST, numpy, and Google) and a plethora of tools to interpret them, among which:\begin{itemize}
		\item Doxygen, which has its own format ;
		\item autodoc (used with Sphinx), which requires to write in ReST (more complete than markdown, but more complex) ;
		\item mkdocstring (used with mkdocs), which uses markdown ;
		\item pdoc3, which uses markdown.
	\end{itemize}
	All three of four generates an HTML output (which is generally what you want). They supports LaTeX formula by various means.
\end{frame}

\begin{frame}
	\begin{center}
		{\LARGE DEMO TIME!}
	\end{center}
	
	Note: \url{https://docs.python.org/3/library/doctest.html}.
\end{frame}

\begin{frame}{Testing}
	\begin{columns}
		\column{.5\linewidth}
		
		Per Wikipedia, ``software testing is the act of checking whether software satisfies expectations". 
		\parskip=1em
		
		It is \textbf{very} important, since it provides ways to check whether your code do what it is supposed to do without proving your code... Which does not guarantee that your code is correct, just that it seems to work under certain conditions, which is already something ;)
		
		\column{.5\linewidth}
	
	\begin{center}
		\begin{tikzpicture}
			\draw (0,0) -- +(5, 0) -- +(2.5, 4) --cycle;
			\draw[latex-latex] (0,-.25) -- +(5, 0) node[midway,below]{Quantity of tests};
			\draw[-latex] (-.25,0) -- +(2.5, 4) node[midway,above, rotate=57]{Time to write};
			\draw[-latex] (5.25,0) -- +(-2.5, 4) node[midway,above, rotate=-57]{Time to execute};
			
			\draw (2.5,.5) node{Unit tests};
			\draw (.62, 1) -- +(3.75,0);
			\draw (2.5,1.5) node{Integration tests};
			\draw (1.25, 2) -- +(2.5,0);
			\draw (2.5, 2.6) node[text centered, text width=1.25cm]{System tests};
		\end{tikzpicture}
		\parskip=1em
		
		(other kind of tests exists)
	\end{center}
\end{columns}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item \textbf{Unit tests}: they test small parts of your code (\textit{i.e.}, a function or a class) and check its behavior. They are quick to run, and are written with the actual implementation in mind (white box testing) and maximize \textbf{coverage} (\textit{i.e.}, most if not all execution paths are checked). In some case, they go beyond checking that the pre/postconditions are true.\footnote{The pre/postconditions can be weaker than the actual implementation.} They generally use mock data.
		\item \textbf{Integration tests}: checks that the functions, classes, modules, etc of your project works together. They are higher level, and are not written with implementation in mind, only the specifications (black box testing). They generally use mock data or very simple real ones (think water in HF/STO-3G to check Mulliken charges).
		\item \textbf{System tests} (also called functional tests): high-level tests (to check that everything works together) with real data from real life. They generally check that the front-end program/library meets its requirements (think real medium-sized molecule, with a realistic method and basis set). They are generally manually launched!
	\end{itemize}
	All these constitute your \textbf{tests suite}.
\end{frame}

\begin{frame}
	Ideally, tests should: \begin{itemize}
		\item Be written as soon as possible. In fact, if you already have the specifications, you can start by writing (unit) tests that check those specifications before even writing the implementation. This is \textbf{test-driven development}. 
		\item Run often. A good practice is to have a \textbf{continuous integration (CI) pipeline}, which generally boils down to a script that runs all your unit and integration tests, automatically launched at every occasion (commit, PR, etc). This helps you to prevent \textbf{regressions}.
		\item Fail quickly. If you have to wait 20 minutes to know if your implementation fails, that's painful. This is why most tools allow you to run only one part of your test suite locally (and this is why \textbf{mock data} are useful).
		\item Be smart: no need to test EVERY input, only a few well-chosen ones ;)
		\item Test as much as possible, but not too much: no need to test that a dependency that you use works as intended, that's their job not yours!
	\end{itemize}
\end{frame}

\begin{frame}
	Speaking of mock data... Yet another \textit{``grimmerie"}:
	\begin{center}
	\includegraphics[width=.7\linewidth]{im/MindlessGen}
	\url{https://github.com/grimme-lab/MindlessGen/}
	\end{center}
\end{frame}

\begin{frame}
	How to write tests:\begin{itemize}
		\item Follow the following structure:\begin{enumerate}
			\item Setup: prepare any data you need for your test ;
			\item Stimuli: run the piece of code you want to test ;
			\item Verify: check that the output matches what you expect ;
			\item Teardown: clean up your mess, if any.
		\end{enumerate}
		In general, the first and last steps are common to many tests (\textit{e.g.}, the starting geometry of water is the same for an energy or optimization calculation).
		\item Separate your tests from your code: you may want to ship your library/program without its tests for actual use.
		\item Use a proper test framework! In python, this means either \texttt{unittest} or \texttt{pytest}, which both provide ways to call your test suite (or some parts of it) smoothly.
	\end{itemize}
\end{frame}

\begin{frame}
\begin{center}
	{\LARGE DEMO TIME!}
\end{center}
\end{frame}

\begin{frame}{Error handling (\textit{exceptions})}
	assert/throw. Also, your user does not want to see your stacktrace (trop d'infos peu digestes).
\end{frame}

\begin{frame}{Data structures}
Other example of abstract data types (list, queue, dictionary, etc).
Note: don't forget $\mathcal O(N)$.
\end{frame}

 \section{POO and POO in Python}
 
 \begin{frame}{What is POO?}
 	\begin{itemize}
 		\item ADT (and internal representation. Example: a molecule and its atoms.
 		\item Methods (CRUDs)  + encapsulation (private/public?).
 		\item Instance of a \textbf{class} + methods.
 	\end{itemize}
 \end{frame}
 
 \section{Organization of a (Python) project}
 
 \begin{frame}
 	\begin{itemize}
 		\item typing and linting
 		\item Use git
 		\item Don't reinvent the wheel (\textit{battery (already) included})
 		\item README \& LICENSE
 		\item packages (\texttt{import stuff})
 		\item Project (\texttt{pyproject.toml})
 		\item virtualenv
 	\end{itemize}
 \end{frame}

\end{document}